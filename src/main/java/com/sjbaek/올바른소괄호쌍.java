package com.sjbaek;

import java.util.Deque;

/**
 * 주어진 문자열 s는 '('와 ')'로만 이루어져 있습니다. 이때 문자열 s에서 올바른 소괄호 쌍의 개수를 반환하는 solution 함수를 작성하세요.
 * 만약 문자열 s가 올바른 소괄호가 아니면 -1을 반환합니다.
 * 올바른 소괄호는 '('로 열렸다면 반드시 짝지어서 ')'로 닫혀야 합니다.
 *
 * 제약조건
 * 1. 1 <= s.length <= 10^5
 * 2. s는 오직 '(') 와 ')' 로만 구성됩니다.
 */
public class 올바른소괄호쌍 {


    /**
     * 문제 분석
     * --------------------------------------------------------------------------------
     * 소괄호 쌍의 개수 -> Stack ( Last In First Out )
     * 압력 : '('와 '(') 로만 이루어진 문자열
     * 출력 : 올바른 쌍의 개수, 올바른 소괄호가 아니면 -1
     * 제약조건에 따른 고려사항
     *  - O(n^2) 선택 시 O(10^10) 으로 O(10^8) 초과하므로 시간 초과, 따라서 최대 O(NlogN) 시간 복잡도 알고리즘 필요
     */

    /**
     * 문제풀이 1.
     * 알고리즘 : Stack (LIFO)
     *
     * Invariant
     * - 루프의 각 단계에서 스택에는 아직 매칭되지 않는 여는 괄호들만 저장된다.
     *   그리고 실제 중첩 순서(가장 최근 것이 top)에 맞게 저장되어 있다.
     * - 지금까지 처리한 접두 문자열이 올바르다면, 닫는 괄호를 만날 때마다
     *   스택이 비어 있찌 않고(top이 존재), top과 현재 닫는 괄호의 타입이 반드시 일치한다.
     *
     * Proof Sketch
     * 1) 여는 괄호를 만나면
     * - 향후 닫아야 하므로 stack에 push한다.
     * 2) 닫는 괄호를 만나면
     * - 스택이 비어 있으면 매칭할 여는 괄호가 없으므로 즉시 -1 반환
     * - 스택 top pop 하고 count를 갱신한다.
     * 3) 모든 문자를 처리한 후
     * - 스택이 비어 있지 않으면 닫히지 않는 여는 괄호가 남아 있으면 -1 반환
     * - 스택이 비어 있으면 모든 괄호가 정확히 매칭되므로 count 반환
     *
     * 시간 복잡도 : O(N)
     */
    public int solution(String s) {
        // 길이가 홀수면 어떤 경우에도 완전 매칭 불가
        if((s.length() & 1) == 1) return -1;

        int answer = 0;
        Deque<Character> stack = new java.util.ArrayDeque<>();

        for(char c : s.toCharArray()) {
            // 여는 괄호는 push
            if('(' == c) {
                stack.push(c);
            } else {
                // 닫는 괄호가 나왔는데 매칭할 '('가 없으면 무효
                if(stack.isEmpty()) return -1;
                stack.pop();
                // 유효한 매칭 1개 획득
                answer++;
            }
        }

        // 여는 괄호가 남아 있으면 무효
        return stack.isEmpty() ? answer : -1;
    }
}
